写出来的代码要让人轻松--从一编码案例谈效率与安全性
日期：2010-10-11 20:29浏览：514评论：8
从一个结构体定义谈起:在定义结构体中，我们常常会遇到若干字段是位域构成。比如如下的再普遍不过的一个结构体：

struct CASE

{

int first;

int second:3;

int third:1;

…..

int reserved:8;

……

}

second与reserved等字段整体占用一个32位空间，如此定义可节省空间，当然也是诸如协议解析和公共代码接口等典型场景下需要如此定义，因为此结构体可以直接与协议完全对应。

 

上述定义有何隐患呢？如果从变化角度来看，如此定义首先有安全性隐患：


场景：如果新增加一个字段，要占用一个bit位，怎么办呢？

解决方法：从reserved扣一个位，如下：

struct CASE

{

……

int first;

int second:3;

int third:1;

int newField:1;

…..

int reserved:7;

……

}

恩，没想到此结构体定义的作者还是有远见的，考虑周全。

 

问题隐患:

可是，此结构体如今被广泛使用，很多地方拿此类型直接申明变量，新增加字段就需要查看所有声明此结构体的地方，并对新增加的newField初始化。而这个是最容易被开发人员所遗漏的，因为没有诸如构造函数的初始化场所，缺乏明显约束，而结构体使用又广泛，且被众多人频繁更改。而我们的产品中就出现过数次此类未初化的问题，而且还曾经引发过非常严重的网上问题,回溯问题时往往被简单地认为是变量未初始化的低级错误(开发人员通常就是唯一的责任人,通常冠以责任心问题)。可是如果再进一步剖析就发现是最初的作者留下了这么个隐患，当初只是简单地把结构体定义出来，但是对字段的初始化没有明显的约束，完全交给使用者，从而留下了安全隐患,也就是说路是有,可是坑坑哇哇的,走路自己要小心,有人跌到了明显是其不小心导致的,可是能否把路修得平整点,让人舒舒服服安安心心地走路呢?

 

消除隐患的改进一：

增加一个构造函数，新增加字段就只需要在构造函数中初始化即可，不需要发挥IDE的搜索功能。代码如下：

second = 0;

third = 0;

newField = 0;

不过很多人可能没有在结构体中加构造函数的习惯，当然还有另外的原因，比如跨平台问题，在老的SUN操作系统环境下，结构体带构函数，则不能一字节对齐了，需要使用一些小技巧避免，比如新增加一个Init的静态函数替换构造函数，当然使用者要显示地调用此函数。

 

遗留的两个问题:

1 好象问题到此就结束了呢？还没有.如果字段非常多，显然构造函数的初始化效率就比较低。

2 此外,上述的定义,在做协议等解析时就非常不方便,因为传输的是字节,要把各个bit位手工拼凑一下,且还要考虑网络字节序(比如不同平台下的结构体定义不同,差别就是各个位的字段定义顺序不同,以适应不同所在cpu的字节序),所以使用上会非常不方便.

提高效率和方便使用的再改进:

有些人可能会如下这么做：

CASE::CASE()

{

memset(this, 0, sizeof(struct CASE));

}

非常省事，代码简洁，效率又高，在构造函数中如此写通常是要严格禁止的，首先如果不小心定义了虚函数，这样的代码就完全在惹事；此外如果结构体有非常多的字符数组或字符串字段，结构体的size非常大，效率就非常低了，我们有的结构体大小是40K左右，有些人非常Happy地memset，导致系统性能急剧下降。可还有什么改进空间呢？

再改进:


struct CASE

{

……

int first;

union FIELDS

{

int initField;

struct BITS

{

int second:3;

int third:1;

int newField:1;

….

}bits;

}fields;

……

}

对位域的统一初始化和赋值使用fields. initField，如果需要使用具体的某个位域时,而使用时fields.bits中的各个字段。嵌套和联合体的使用，更直观地表达了意图，同时让结构体的使用更灵活更安全更高效，可读性更好,也更简洁:比如对于很多场景可以节省位的‘或’、‘与’和‘移位’的操作，同时结构体在不同平台下仅仅只需要上述一芬定义即可,网络字节序转换等也比较简单,还可节省很多不必要的常量定义。

 

小结:此编码细节，或许不足挂齿，但是在我们产品编码中，却有诸多被许多开发人员所忽视的地方.要写出没BUG代码的确不容易，要写出简洁高效率可读性好的代码更不容易，要写让人舒服省心的代码更更不容易。

 

分享此小案例的主要意图是想传达:追求完美代码永无止境,完美太理想,但是至少应该让别人使用你的代码时"轻松"一点,如果你想到你的代码在未来一两年或数年都将可能被无数人阅读和修改,那么你就应该多做一点.

 

呵呵,项目刚好搞完,而在这个项目中也遇到了此类结构体的使用场景,故分享之,组织有点混乱,请谅解:)
