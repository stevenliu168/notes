偷走性能的三方面--互斥锁、条件变量和inline
日期：2015-12-23 18:08浏览：2196评论：11
前段时间做融合消息中的短信部件的性能优化，迁移到新平台后，性能下降严重，而此部件业务逻辑已是相当成熟，也经过数轮优化，潜力应该被挖掘得所剩无几，深入分析，发现没有被注意到的大把偷走性能的三方面，基础代码中，互斥锁与条件变量在线程同步与消息传递中最被广泛使用。在构建如此关键的基础设施时，互斥锁与条件变量是否是合适的呢？

1、互斥量是否是高效率的？

互斥锁的实现原理概要：

锁的方式有多种，互斥量是最常见的，我们的选择也是互斥量，它是否是高效率的？

我们分析一下它的实现原理：数据结构是一把锁（自旋锁）保护一个等待队列和一个引用计数器，工作原理是为了尽量降低CPU占用率，当获取锁时，先在内部锁的保护下对引用计数器减1（或加1）操作，然后检测计数以确定锁是否被占用，如果未被占用，获得锁进入临界区，否则调用栈被挂在锁的等待对列上，线程被唤出。而占用锁的线程释放锁时候，则会从等待队列上唤醒一个线程让线程执行。故我们常常看到如下的堆栈：

加锁的调用栈大致如下：

#0  0x00002b9a6e51e294 in __lll_lock_wait () from /lib64/libpthread.so.0

#1  0x00002b9a6e519619 in _L_lock_1008 () from /lib64/libpthread.so.0

#2  0x00002b9a6e51942e in pthread_mutex_lock () from /lib64/libpthread.so.0

释放锁的调用栈大致如下：

#0  0x00002b9a6e51e294 in _lll_unlock_wake () from /lib64/libpthread.so.0

#1  0x00002b9a6e519619 in _L_unlock_1008 () from /lib64/libpthread.so.0

#2  0x00002b9a6e51942e in pthread_mutex_unlock () from /lib64/libpthread.so.0

互斥锁的性能陷阱概要：

互斥锁的实现会带来什么问题呢？当锁冲突严重时，存在上述堆栈的大量线程唤出唤入操作，而这种开销很可能远远大于临界区自身的开销。而我们的业务加锁场景，通常是对容器、队列、资源和计数等对象的操作加锁，而对象的操作，比如链表，是非常短暂的，不应该被打断和停留，那么互斥锁不适合做这类操作的加锁。

问题现象：CPU占用率无法提高，看着好像比较闲，比较闲是因为短暂的互斥就可能打断运行中的线程，让线程不得不休息，走走停停，耗能不说，又很可能无法开足马力，性能当然也上不去。

解决思路：

短暂的加锁，能否不用唤出唤入呢？那就是自选锁，实现原理就是自己傻等，刚好弥补了互斥锁的不足。 互斥锁就是窗口有人办理业务时，后面的人被请到休息室喝茶，办完一个，再到休息室来叫，表面现象就是一团和气，而不是忙忙碌碌，适合时间长、小批量的VIP业务。而自选锁就是前面有人，就站着等，办完一个后面人自动顶上，表面现象就是忙忙碌碌，永不停歇，犹如我等**丝在食堂吃个饭就是打仗，适合比较紧急的，比较短暂的，且不能被打断的。

自选锁的陷阱：

不能重入，同一个线程也不能加锁两次，加锁两次就会导致死锁，且CPU占用率100%，与互斥锁的比对：如果是自旋锁两个线程死锁，两个线程每个CPU占用率都是100%，如果是互斥锁，两个线程的CPU占用率都是0。

 

2、条件变量的实现是否是高效率的呢?

条件变量的实现原理概要：

条件变量通过允许线程阻塞和等待另一个线程发送信号的方法良好地支持了雷同消费者模式的消息通知机制，但是条件变量本身需要互斥锁来保护，这就注定了它的效率比较低。

 

解决思路：

a、  不要每次消息投递都把灯点亮，点亮一次等意味着一次互斥锁加锁，一次消息通知。当先前已经通知过，而通知还没被抹去（比如消息队列中积压消息数大于1），就不要再通知了（因为第一条消息已经通知了）。

b、  条件变量往往结合消息队列等使用，消息队列的用户上下文自身一般是有互斥锁的，故条件变量的互斥锁可以共用这个互斥锁，减少一次加锁操作。

c、  把条件变量更换为信号量，而条件变量使用的上下文的互斥锁更换为自旋锁。

d、  对于不实时处理的消息，消息处理线程可以结合sleep机制，循环检测是否有消息，而投递方也不需要做消息通知，由消息处理方自行检测，对于高并发的消息处理，并发性能是最好的选择。

 

3、让人失望的inline

Inline只是告诉编译器内联，在未加编译优化选项，及时打开-finline-functions或-finline-small-functions，编译器基本忽略了任何inline，均未对小函数内联，如何增强内联呢？对于gcc/g++编译器，有个attribute属性，可以给函数指定许多我们意想不到的约束与检测，而让编译器内联也是其中一项，当然在windows下已经有宏了，具体如下：

#ifdef _WIN32 // for MSVC

#define _forceinline_ __forceinline

#elif defined __GNUC__ // for gcc on Linux/Apple OS X

#define _forceinline_ __inline__ __attribute__((always_inline))

#else

#define _forceinline_ inline

#endif

 

要内联的函数如下：

_forceinline_ void  smallFunction()
