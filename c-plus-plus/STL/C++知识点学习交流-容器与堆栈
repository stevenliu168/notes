http://3ms.huawei.com/km/groups/3803117/blogs/details/9042925
题目（多选题）

下列代码都是函数内部声明的局部变量，其中可能会导致栈空间不足的有（）
A.  int var[1024 * 1024];
B.  std::array<int, 1024 * 1024> var;
C.  std::vector<int> var(1024 * 1024);
D.  std::pair<int, int[1024 * 1024]> var;
E.  std::string var(1024 * 1024, 'c');

题目解析

在C++语言中，函数内声明的局部变量，以及按值传递的函数参数，会占用栈空间，而使用new或者malloc方式申请的对象或内存占用的是堆空间。栈内存与堆内存的区别是C/C++语言中一个重要的知识点。在运行环境上，通常线程可用的栈空间比堆空间要远小得多：栈空间一般只有几M，甚至小于1M，而堆空间往往高达几个G。因此，在程序中存储大块的数据时，必须要注意不能造成栈空间不足。通常当函数内的局部变量或函数形参占用空间超过1kB时，就要考虑是否该分配在堆上了[1]。

但是，由于C++的对象可以做复杂的封装，实际数据是存储在栈上还是堆上往往并非那么直观。在这道题中，分别有4种标准库工具用于存储大块数据，要了解存储的方式，需要对标准库的实现有一定的了解。

我们先来看看几个选项：
选项A是一个数组，它的所有数据会直接按连续空间存放在栈上，因此使用很大的数组是有栈越界风险的。
选项B是std::array，作为局部变量时是存放在栈上的，因此有栈越界风险。
选项C是std::vector，实际数据都会被保存在堆上，栈中只保存了指针，因此没有栈越界风险。
选项D是std::pair，第2个模板参数实例化如果是大对象，也有栈越界风险。
选项E是std::string，对数据的管理方式与std::vector类似，因此没有栈越界风险。

实际答题情况

实际作答数据显示，大部分人都了解数组的栈溢出风险，但是有不少人没有选择std::array和std::pair。另一方面，也有相当一部分人错误的判断了std::vector和std::string的栈溢出风险。综合下来，完全答对此题的比例很低。这说明很大一部分开发人员对标准库容器的了解还不够。

知识点解读

下面我们延伸一下，看看题目中出现的几个常用模板的数据管理方式：

（1）std::array

std::array是C++11新加入的容器。很多人对std::array不太了解，但其实在现代C++程序中，推荐用std::array来代替传统数组，因为它在不新增开销的前提下，提供了很多方便的操作，如size()获取大小，begin()/end()操作迭代器等等。另外std::array不会隐式转换为指针的特点也可以避免sizeof不当使用造成的一类经典问题。
由于std::array的目标是性能逼近传统数组，因此它的所有数据是直接存放在栈上的，没有堆内存管理的功能。因此不宜用std::array存放大块的数据。

（2）std::vector

std::vector是最常用的容器之一，它是一个大小可动态伸缩的线性存储器。std::vector带有堆内存的管理功能，其内部的实现其实是3个指针。当所分配的堆空间不够用时，std::vector会自动新分配更大的空间，将已有数据移动到新空间，并释放原有的空间。

因此，使用std::vector存储大块的数据是允许的。实际数据都会被保存在堆上，栈中只保存了std::vector内部的3个指针而已。

（3）std::pair

std::pair是一个工具类，它是一个很简单的封装两个对象的模板，其本身没有堆内存管理功能。保存在std::pair中的两个对象的类型分别通过两个模板参数来指定。在这个选项中，第2个模板参数实例化为了一个超大数组，会导致std::pair占用超大栈空间。数组作为函数参数时会退化为指针，因此可能有的人误以为数组作模板参数也会变成指针。但实际上数组是C/C++中确定大小的数据类型（[]中的数字不能省略），在声明为函数参数时变为指针只是一个特例。

（4）std::string

std::string是常用的C++字符串，它其实是std::basic_string模板对char类型实例化的模板类。std::basic_string对数据的管理方式几乎和std::vector一样，只是支持的操作不同（比如可以用+操作符进行连接）。因此把大块数据放在std::basic_string中是不会产生栈溢出的。

知识点的重要性

不了解数据实际存储位置、函数递归调用层次过深、函数参数误使用超大对象等都是造成栈溢出的常见原因。栈溢出以后会不知不觉的修改其他无关对象的内存内容，导致一些极难定位的古怪问题，因此它是程序员最深恶痛绝的BUG之一。

在程序员界最著名的问答网站就以“栈溢出”作为自己的名字，这是在2008年4月时由Coding Horror网站读者投票所选出的域名，体现了程序员们对经典BUG的戏谑[2]。



推荐学习资料

对于栈和堆的基本原理，任何一本C或C++语言的教材都会涉及。推荐阅读经典的C++入门书籍——《C++ Primer》。
对于STL容器的用法和特点，推荐阅读《The C++ Standard Library》。
CppReference是一个很好的在线参考文档，对于标准库中任何一种工具有疑问都可以在这个网站上获取详细的用法阐述。

尾注
【1】 见《华为C语言编程规范 V5.0》的“G.VAR.03 避免大量栈分配”。
【2】https://blog.codinghorror.com/help-name-our-website/
