固定网络BU
“软件人员能力提升” 课程系列
——设计模式(V1.0)
课程承接部门：USP平台开发部
课程开发者：颉瑞昌/59321
原作者：杜军，张森,  未海洪

平民重构，你能！
张伟118807
目录
	设计模式简介
	为什么要学设计模式
	什么是设计模式
	设计模式分类
	设计模式详解
	创建型模式详解
	结构型模式详解
	行为型模式详解
	设计模式实践
	学习设计模式
	应用设计模式
	超越设计模式
	附录
	C语言和设计模式

软件设计开发中，经常会遇到以下场景：
•	我要实现的这个特性中有一些被频繁使用的代码，并且在其它特性中也被用到了，我不想总是做重复的事，那样费力且容易出错，因此需要一种方法能把这些稳固的代码抽象出来。
•	这两个模块耦合太紧密了，代码一团糟，你中有我，我中有你，真令人抓狂！有什么办法彻底解耦吗？
•	常听到有人抱怨说软件实现太灵活了，每个人都有不同的思路。那么如何才能让一个团队的代码看起来犹如同一个人写的那样，具有良好的可读性和可维护性呢？
•	……


学习什么模式的作用：
•	提供学习已有代码的方法，可快速地了解现有系统；
•	加快软件设计速度，能快速地将分析模型转换成实现模型；
•	软件设计交流的通用词汇。
什么是设计模式？

“设计模式”的定义是这样的：A design pattern in architecture and computer science is a formal way of documenting a solution to a design problem in a particular field of expertise. 

在计算机科学中，其实就是针对一系列常见的代码实战场景所做的范式化归纳。设计模式采用多种方法解决面向对象设计者经常碰到的问题——描述典型场景下、一类设计问题的解决方法。
设计模式分类
•	创建型模式——与对象的创建有关；
•	结构型模式——处理类和对象的组合；
•	行为型模式——对类对象怎样交互和怎样分配职责进行描述；









目录
	设计模式简介
	为什么要学设计模式
	什么是设计模式
	设计模式分类
	设计模式详解
	创建型模式详解
	结构型模式详解
	行为型模式详解
	设计模式实践
	学习设计模式
	应用设计模式
	超越设计模式
	附录
	C语言和设计模式
目录
	创建型模式——对象的创建
	Abstract Factory 
	Builder
	Factory Method
	Prototpye
	Singleton
FACTORY METHOD(工厂方法)
•	定义：
	定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。
	* 将被创建对象的信息从框架中分离出来。

•	场景：
	框架需要实例化对象，但不想感知具体的对象类，只操作对象的抽象类；	










FACTORY METHOD(工厂方法)
•	结构：










FACTORY METHOD(工厂方法)
•	实现——使用(client)







FACTORY METHOD(工厂方法)
•	实现——实现







FACTORY METHOD(工厂方法)
•	实现——实现







FACTORY METHOD(工厂方法)
•	建议
	A、使得框架不包含创建对象(具体)的信息；
	B、如何定义具体对象的信息，要依据设计环境决定(不是越灵活越好)。








ABSTRACTOY FACTORY(抽象工厂)
•	ABSTRACT FACTORY——使用
ABSTRACTOY FACTORY(抽象工厂)
•	ABSTRACT FACTORY——实现
FACTORY METHOD和ABSTRACTOY FACTORY区别
•	定义：
	AF是创建一系列相关对象的接口(方法的集合)；FM创建对象的接口(一般是不同的、单个对象)。

•	Client(保护对象)：
	AF不需要指定(创建对象的)的具体类；FM不感知工长方法，仅仅通过一个工厂的接口创建具体类(一般需要给接口传入对象信息)。

•	联系：
	AF一般会FM来实现(进一步抽象)：AF仅提供一个接口，每个产品定义一个工厂方法；FM的实现较复杂些，但只需要一个新的工厂接口(函数)，而AF需要一个新的类，因此，通常将FM作为一种标准的创建对象的方法。
ABSTRACT FACTROY 实例？
•	单元测试测试？
•	单元测试源代码？
ABSTRACT FACTROY 实例——CppUnit
SINGLETON(单件)
•	定义：
	保证一个类仅有一个实例，并提供一个访问它的全局访问点。

•	场景：
	有一个全局的入口，使得可以被访问；
	只实例化一个对象；
	

SINGLETON(单件)
•	示例——使用

SINGLETON(单件)
•	示例——实现一

SINGLETON(单件)
•	注意：
	A、对唯一实例，可做到受控访问(增加调试)
	B、是全局变量的改进：缩小名字污染(慎用)。

目录
	结构型模式——处理类和对象的组合
	Adapter
	Bridge
	Composite
	Decorator
	Facade
	Flyweight
	Proxy
ADAPTER(适配器)
•	定义：将一个类的接口转换成客户希望的另外一个接口。该模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。









ADAPTER(适配器)
•	结构：









ADAPTER(适配器)
•	示例——使用






ADAPTER(适配器)
•	建议：
	A、原本不兼容的两个类，通过适配层，可以一起工作；
	B、通过增加适配层增加功能(调试)；








BRIDGE(桥接)
•	定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

•	场景：当一个对象有多个维度(一般是两个)维度的变化时，就需要使用bridge。










BRIDGE(桥接)
•	结构：
BRIDGE(桥接)
•	示例：以 linux kernel 的网络设备模型作为考察对象。

BRIDGE(桥接)
•	如果我们把网络设备视为对象的话，很自然地，设备的操作方法应该是设备对象方法的一部分。但不同类型的网络设备的操作方法集不同，因此它是代码中剧烈变动的部分。同理，相同类型的网络设备对象的操作方法集相同，应该让它被共享(hybird)。
BRIDGE(桥接)
/*
  * 使用了Bridge模式之后，对象的操作和对象的抽象分离，
  * 避免了耦合，隔离了不同设备的动作差异，也提高了重用度。
  * 打开和关闭设备的代码可以这样写，并且不受具体打开和
  * 关闭动作细节的影响。
  */
if (netif_running(netdev))
        netdev->netdev_ops->ndo_open(netdev);

if (netif_running(netdev))
        netdev->netdev_ops->ndo_stop(netdev);
BRIDGE(桥接)
•	建议：
	A、提高可扩展性。









FACADE(外观)
•	定义——为子系统中的一组接口提供一个一致的界面。该模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

•	场景：





FACADE(外观)
•	这个模式在我们的系统中很常见：一个复杂子系统只提供了一个简单接口，从而对客户屏蔽了内部细节，达到调用和实现解耦的目的。如：接口人就是facade的体现。
FACADE(外观)
•	结构：
FACADE(外观)
•	示例——实现





FACADE(外观)
•	建议：
	A、降低了客户和子系统之间的耦合度；
	B、增加一层封装，小心“胖接口”。

目录
	行为型模式——处理对象怎样交互和怎样分配职责
	Chain Of Responsibility
	Command
	Interpreter
	Iterator
	Mediator
	Memento
	Observer
	State
	Strategy
	Template Method
	Visitor
STATE(状态)
•	定义：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

•	场景：
	A、对象的行为取决当前状态，且状态在运行时可变；
	B、多条件分支；
STATE(状态)
STATE(状态)
•	示例——实现
STATE(状态)
STATE(状态)
STATE(状态)
OBSERVER(观察者)
•	定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并被自动更新。

•	场景：
	A、一对多的依赖；
	B、对象状态发生改变时，依赖于它的对象被通知；
OBSERVER(观察者)
•	结构
OBSERVER(观察者)
•	示例——实现
OBSERVER(观察者)
•	示例——实现
OBSERVER(观察者)
•	示例——实现
OBSERVER(观察者)
•	示例——使用
OBSERVER(观察者)
目录
	设计模式简介
	为什么要学设计模式
	什么是设计模式
	设计模式分类
	设计模式详解
	创建型模式详解
	结构型模式详解
	行为型模式详解
	设计模式实践
	学习设计模式
	应用设计模式
	超越设计模式
	附录
	C语言和设计模式
设计模式之外——如何学习模式
•	每个模式的要素：
–	记住定义：
	对模式精炼的描述。

–	理解场景：
	a、 解决什么问题；
	b、 模式应用的前提条件；
	c	、设计的动机：要保护什么那部分代码东西(抽象和具体)。

–	熟悉实现：
	理论和实践的结合。

–	知道优缺：
	应用模式时，做到知己知彼。
设计模式之外——如何学习设计模式
•	设计模式的修炼
–	应用设计模式的软件设计分三个层次：
–	第一层次：通过模式去套需求——邯郸学步；
–	第二层次：将需求用合适的模式实现——独孤九剑；
–	第三层次：需求实现后，发现完全符合模式——心中无剑。
设计模式之外——如何应用设计模式
•	设计(软件开发)

–	就是将需求转换成代码。	

设计模式之外——如何应用设计模式
•	如何进行设计
–	分析需求，用最恰当的方式，实现之。

•	如何用”设计模式” 进行设计
–	首先，理解和分析需求(目标)； 
–	然后，分析出需求变化和不变化的地方(不变的就是抽象，变化的就是差异；二者界限就是“特性隔离点”)；
–	最后，根据抽象和差异，用恰如其分的模式实现之(理解每个模式的场景、动机很重要！)。

设计模式之外——超越设计模式
•	Open/Closed Principle (OCP) – 开闭原则
•	“模块是可扩展的，但是不可修改的”：也就是说，对扩展是开放的，而对修改是封闭的(关键是抽象)。
•	对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 
•	比如我们STL中的各种算法，允许你提供一个“比较器”，浏览器的各种插件也属于这个原则的实践。

•	Single Responsibility Principle (SRP) –职责单一原则
•	“一个类而言，仅有一个引起它变化的原因”：一个类，只做一件事，并把这件事做好。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间产生更多影响(Bridge)。

•	Liskov substitution principle (LSP) – 里氏代换原则
•	“子类必须能够替换成它们的基类”：LSP给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系(Is-A, Has-A)(Abstract Factory)。

•	Interface Segregation Principle (ISP) – 接口隔离原则
•	“不应该强迫客户依赖于它们不使用的方法”：强迫客户依赖不使用的方法，导致客户面临由于这些未使用方法的改变所带来的变更。违法ISP，就形成所谓的“胖接口”，也意味着功能不内聚(Facade)。

•	Dependency Inversion Principle (DIP) – 依赖倒置原则
•	“高层模块不应该依赖于低层模块的实现，二者都应该依赖于抽象”：举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。实现框架设计的核心原则(PPI申请)。

设计模式之外——超越设计模式
•	敏捷设计五原则的关系:
–	开闭原则是中心主题
是软件设计的终极目标；
–	依赖倒置、里氏替换可实现扩展性
依赖倒置是框架设计的核心原则，因为我们的目标是要实现框
架的稳定和重用；里氏替换原则可以保证client代码的稳定和封
闭性；
–	单一职责是其它四个原则实现的基础
违法单一职责意味着模块有多一个轴线的变化，这样一个职
责的变化对其它职责带来联动，即耦合。
–	接口隔离是对单一职责最好的体现。
设计模式之外——超越设计模式
•	朝着目标，在取舍与平衡中设计：
–	可扩展性
现有的设计和代码，对新增特性(体现到研发，就是写代码)，要能很容易支
持 -- 也就是说：对于扩展是开放的；(OCP的实现，技术上抽象类是实现关键)；
–	 封闭性
		 扩展新特性时，不必修改已有的代码——也即是说：对更改是封闭的；(这样自然就onetrack了)；

     在达到前面两个目的的同时，必须考虑：
–	易用性
让用户(平台和架构的用户就是开发人员)易用：写代码很轻松！-- (这点是对前
面两点的约束：以免“过设计”: 为满足i), ii), 而导致不好用)；
–	 简洁性
为满足前三者而采用的各种设计方法，一定不要太复杂，要简单。-- (这点是对
前面三点的约束：以免“过设计”: 为满足i), ii), iii)而导致实现很复杂)。
目录
	设计模式简介
	为什么要学设计模式
	什么是设计模式
	设计模式分类
	设计模式详解
	创建型模式详解
	结构型模式详解
	行为型模式详解
	设计模式实践
	学习设计模式
	应用设计模式
	超越设计模式
	附录
	C语言和设计模式
附录：C语言之于OO

    C语言是为写可移植的UNIX设计的，是对纷繁的CPU指令的一种高度抽象。可以理解成面向人类的，与机器无关的“汇编语言”。

      要想用C语言实践设计模式，就必须掌握OO的基本要素和一点点实现的技巧。

                 工欲善其事，必先利其器。
OO的基本元素
•	继承 – 也叫泛化。派生类（子类）拥有父类的全部属性和方法，并且也可包含它们自己的。
•	封装 –通过限制只有特定类的实例可以访问这一特定类的成员，通常利用接口实现消息的传入传出。
•	多态性–是指由继承而产生的相关的不同的类，其对象 对同一消息会做出不同的响应。
•	组合 – 一个对象由多个子对象组合在一起构成。它们具有一样的生命周期。比如人的四肢和人体本身是密不可分的，不可独立存在。
•	聚合 – 一个对象由多个子对象组合在一起构成。子对象具有自己的生命周期。比如一辆汽车，即便它的发动机寿终正寝了，也许它的轮胎、玻璃、座椅等部件还可以使用。
泛化：继承
一个类是从另一个类继承而来的。C++有约定的语法来处理这种关系。C可以这样做。

泛化：多重继承
一个类是从其它多个类继承而来的。

组合
一个对象是由多个对象组合而成的，并且它和构成它的子对象集有同样的生命周期。

聚合
一个对象是由多个对象组合而成的，但子对象具有独立的生命周期。
数据结构
•	数据结构的设计是体现OO思想最关键的地方。有这样一句话：“所谓面向对象，就是抽象出具有动作的数据；所谓闭包，就是抽象出具有数据的动作”。
数据结构
•	OO数据结构的特征有二：
•	属性：这个对象有哪些特性？
•	方法：这个对象如何与其它对象互动？也就是我们常说的函数。

•	只有紧密相关的一组元素才能内聚在一起，构成对象。
•	与外界如何交互，是由对象的职能决定的。
案例：系统中的OLC算法是面向过程的设计。如果要体现OO，那么可以这样做：
struct bucket_node {
    char name[NAMESZ];
    struct list vlist;   /* 用于父子指针 */
    struct list hlist;   /* 用户兄弟指针 */
    struct hlist nlist;  /* 用于加速查找的 hash 表指针*/

    u8 weight;           /* 占上级溢出门限的权重，其值等于实际
                          * 分配权重乘以100，如果不占权重，其
                          * 值等于 0
                          */
    u16 overflow;        /* 计数器溢出门限, 0表示透传 */
    u16 idle_tok;        /* 空闲令牌计数器 */
    u16 threshold;       /* 计数器门限，缺省等于系统令牌数 */
    u16 meter;           /* 实时计数器 */
    u16 limit;           /* 报文限速(pps)，0表示不限速 */

    /* 换下页 */
    

    /* 接上页 */
    /* 用于刷新水位 */
    u32 c_deficiency;   /* 固定更新：子节点空闲令牌总数 */
    u32 c_debt;         /* 固定更新：子节点债务总数 */
    u32 r_deficiency;   /* 实时更新：子节点空闲令牌余额 */
    u32 r_debt;         /* 实时更新：子节点债务余额 */

    s16 type;           /* 节点的类型 */
    s16 height;         /* 节点在树中的高度 */
    u16 ext_nrs;        /* extend的个数 */
    u16 index;          /* 节点在数组中的索引 */
    u32 flags;          /* 节点标志bitmap */

    u16 (*inc_meter)(struct bucket_node *);  /* 实时增加流量计数 */
    u32 (*process)(struct queue *);          /* 处理队列消息 */
    void (*destroy)(struct bucket_node *);   /* 释放自己 */

    void * extend[0];   /* 扩展的用途：
                         *    1. 对于root节点，extend[0]记录最后一个被选
                         *       择的core;extend[1]记录所有的高优先级节
                         *       点;
                         *    2. 对于core节点，extend[0]记录第一个leaf；
                         *       extend[1]记录最后一个被选择的leaf;
                         *    3. 对于leaf节点，extend[0]记录同core的下一
                         *       个leaf;extend[1]记录指向报文队列的指针;
                         */
};


