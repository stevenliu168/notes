设计原则与设计模式的关系
Command-Query Separation (CQS)
命令-查询分离原则，CQS原则在设计接口上，如果可能，应该尽量使接口单一化，保证方法的行为严格的是命令或者是查询，这样查询方法不会改变对象的状态，没有副作用。实际应用时在语义的清晰性和使用的简单性之间需要权衡。另外补充一点说明：更改状态，需要封装成函数或宏定义，方便扩展。命令查询分离，最早是Betrand Meyer 在《Object-Oriented Software Construction》一书中提出的概念，该概念指出，任何类的方法，要不就是一种命令，命令不会返回任何结果，但会改变对象的状态，要不就是一种查询，查询会返回结果，但是不会改变对象的状态，对系统没有副作用。
现在很多应用中读和写都是组合在一起，但是这样会导致一个问题，随着系统越来越庞大，功能越来越细，读写使用同样的模型将会很难维护和优化。命令和查询分离的好处有：
1. 方便优化和调试，你可以单独对读系统进行优化，常见的优化方式有数据库的读写分离，写主读从，主从复制。这样一来可以横向的扩展读的性能。
2. 另外一个好处就是面对较大的项目，可以将开发人员分成更小的组来进行开发，负责写的开发人员只需要专注于数据库的更新、删除和插入，不需要了解如何去进行索引查询优化等读相关的技术，
专注于读的开发人员也不需要了解复杂的领域模型DomainModel ，只需要专注于视图模型ViewModel 即可。
如下是一个典型的读写分离场景，这样的读写分离可以将主库的读的压力分散给从库，主库只负责用户的写入，从库使用复杂均衡策略来响应用户的读，从而来提升系统的读写性能。




那么什么时候应该使用命令和查询分离呢？
通常来说，当你在开发一个协作度高，规模大、用户多的系统时，你可以使用命令查询分离来降低开发复杂度。或者说你想提高系统的读写性能，你可以使用读写分离策略来提高系统的读写性能和横向扩展能力。
那么什么时候不应该使用该原则呢？
当你开发的系统非常简单，不具备上述条件时，千万不要刻意去使用该原则，这样会将一个简单的系统开发复杂化。
设计原则与设计模式的关系
约定大于配置
在开发过程中，应该尽量使用约定来代替配置，maven就是使用约定来代替配置文件，通过和开发者约定java为源代码目录、resources目录为资源目录。这样maven就能清楚如何对项目进行打包了。
我们在开发中常常会存在前后端接口调用，现在微服务架构中也往往有服务之间的调用，假设前后端在接口上不在url 上进行约定的话，那么前端就需要承担维护后端接口url 的工作。
假设后端有一个用户模块，有一个查询用户详细信息的接口url 为/users/getUserDetailsById ，那么必须前端维护一个users.json 的配置文件来将所有和用户相关的接口url 维护起来，否则url 路径
将会在前端代码中到处都是，比如这样的代码。

设计原则与设计模式的关系
Law of Demeter – 迪米特法则
迪米特法则(LoD)，又称“最少知识原则”。迪米特法则又称为一个对象应该对其他对象保持最少的了解，只与自己熟悉的对象进行通信。在《Clean Code》一书中，有一段违反了LoD的代码：
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 增加了耦合，使得代码结构复杂、僵化，难以扩展和维护。一个对象对其它对象的内容更有兴趣，老是羡慕别的对象的成员、结构或者功能，大老远的调用人家的东西，这样的结构显然是不合理的。应该调整程序的结构，让那个对象自己拥有它羡慕的feature，或者使用合理的设计模式（例如Facade和Mediator）。




年级主任想了解某个班所有同学的名字，他可以和这个班的班主任进行沟通，也可以和
班里的每一个同学进行沟通，很显然，前者更加符合逻辑，因为年级主任和每个班上的同学是不熟悉
的，并且和同学们一一沟通的成本太高。


年级主任只需要和班主任进行通信了就可以获取到该班所有学生的信息，不需要去和班上的每个
同学去进行通信，降低了年级主任和学生之间的耦合度。
面向对象的SOLID 设计原则
Single Responsibility Principle (SRP) –职责单一原则
其核心的思想是：一个类，只做一件事，并把这件事做好。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间产生更多影响。在面向对象的世界中，如果一个类承担的职责过多，那么这些职责就会耦合在一起，这种耦合将直接导致脆弱的设计。






面向对象的SOLID 设计原则
Open/Closed Principle (OCP) – 开闭原则
其核心的思想是：开放封闭原则简称开闭原则，规定软件中的对象(模块、类和函数)应该对于扩展是开放的，对修改是封闭的。也就是说，对扩展是开放的，而对修改是封闭的。对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。这个术语是一个叫波特兰.麦耶的家伙在1988年发行的《面向对象软件构造》中给出的，他认为一个类只应该因为错误而对其进行修改，新的特性应该通过新建不同的类来实现。


我们要抽象出一只鸭子类，突然某一天，我们发现鸭群中有一只唐老鸭，它不仅会嘎嘎叫，它还会讲话。此时，去修改Duck 接口的话将会使得NormalDuck 也具有说话的能力，显然是不合适的。对于这个新的特性，我们可以通过新增另外一种特性接口，来构建唐老鸭这只不同的鸭子。

面向对象的SOLID 设计原则
Liskov substitution principle (LSP) – 里氏代换原则
子类必须能够替换成它们的基类。LSP给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。里氏替换原则主张将设计中的静态结构改动为动态结构，维持设计的封闭性。这是什么意思呢，我们用通俗的话来讲就是所有父类对象出现的地方都能使用一个子类的对象来代替，并且程序不会产生任何错误和异常。
里氏替换原则允许子类扩展父类没有的方法，但是不主张重写父类的方法，如果一定要重写，那么可以在子类和父类的基础上进一步的抽象，让子类和父类同时继承这个抽象，然后去除已有的继承关
系。

我们都去饭店吃过饭，我们知道普通顾客和VIP 顾客打折力度是不一样的。Restaurant因此就可以根据Customer 的不同来打折。

面向对象的SOLID 设计原则
Interface Segregation Principle (ISP) – 接口隔离原则
接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。例如，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，等等，如果我们把这些功能都声明在电脑的抽象类里面，那么我们的上网本，PC机，服务器，笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。

接口隔离原则强调客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上


面向对象的SOLID 设计原则
Dependency Inversion Principle (DIP) – 依赖倒置原则
高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。
依赖倒置原则强调面向接口编程，表明高层的模块不应该依赖低层的模块(具体的实现),相反，高层的模块应该依赖接口或抽象类。

创建型模式
创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。


创建型模式分为以下几种。
原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。
单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。


以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式.

简单工厂模式
	定义
简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。


	模式结构
	Factory：工厂角色
	工厂角色负责实现创建所有实例的内部逻辑
	Product：抽象产品角色
	抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口
	ConcreteProduct：具体产品角色
	具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

简单工厂模式
	模式分析
将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。
在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。
简单工厂模式最大的问题在于工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的。
简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。
	优点
工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
	缺点
由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
简单工厂模式由系统扩展困难，一旦添加新产品就不得不于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。
修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
	适用环境
在以下情况下可以使用简单工厂模式：
工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。
Java加密技术
获取不同加密算法的密钥生成器:
创建密码器:





工厂方法模式
	定义
工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。
工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。

	模式结构
	Product：抽象产品
	ConcreteProduct：具体产品
	Factory：抽象工厂
	ConcreteFactory：具体工厂

工厂方法模式
	模式分析
工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。
	优点
	在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。
	基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。
	使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。
	缺点
	在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。
	由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
	适用环境
	一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。
	一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
	将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。
	模式应用
某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，
且用户可以根据要求动态选择日志记录方式， 现使用工厂方法模式设计该系统。





抽象工厂模式（Abstract Factory）
	模式动机
在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。
为了更清晰地理解工厂方法模式，需要先引入两个概念：
	产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。
	产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。
当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。
抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。
抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。

	定义
抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

	模式结构

	AbstractFactory：抽象工厂
	ConcreteFactory：具体工厂
	AbstractProduct：抽象产品
	Product：具体产品

抽象工厂模式（Abstract Factory）
建造者模式
	模式动机
      无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发送机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。

定义
建造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。

模式结构
Builder：抽象建造者
ConcreteBuilder：具体建造者
Director：指挥者
Product：产品角色


建造者模式
建造者模式
	模式扩展
	建造者模式的简化:
省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。
省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让
Builder角色扮演指挥者与建造者双重角色。
	建造者模式与抽象工厂模式的比较:
与抽象工厂模式相比， 建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。
在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。
如果将抽象工厂模式看成 汽车配件生产工厂 ，生产一个产品族的产品，那么建造者模式就是一个 汽车组装工厂 ，通过对部件的组装可以返回一辆完整的汽车

单例模式
	模式动机
对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。
如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。
一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。
在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、Web 应用的配置对象、应用程序中的对话框、系统中的缓存等常常被设计成单例。

	定义
单例模式(Singleton Pattern)：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。
单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是对外提供一个访问该单例的全局访问点。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。
常见的单例模式的实现可以分为懒汉式和饿汉式，这两种创建方式，是有缺陷的，懒汉式的缺点就是线程安全问题，恶汉式的缺点就是提前占用内存。

	模式结构
单例模式的主要角色如下。
	单例类：包含一个实例且能自行创建这个实例的类。
	访问类：使用单例的类。


单例模式
	优点
提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。
由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。
允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。
	缺点
由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。

	适用环境
系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。
客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。
在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式

	模式应用
一个具有自动编号主键的表可以有多个用户同时使用，但数据库中只能有一个地方分配下一个主键编号，否则会出现主键重复，因此该主键编号生成器必须具备唯一性，可以通过单例模式来实现。
在操作系统中，打印池(Print Spooler)是一个用于管理打印任务的应用程序，通过打印池用户可以删除、中止或者改变打印任务的优先级，在一个系统中只允许运行一个打印池对象，如果重复创建打印池则抛出异常。现使用单例模式来模拟实现打印池的设计。


结构型模式
结构型模式描述如何将类或对象按某种布局组成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。

由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。

结构型模式可以分为类结构型模式和对象结构型模式：类结构型模式关心类的组合，由多个类可以组合成一个更大的。
系统，在类结构型模式中一般只存在继承关系和实现关系。  对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。

结构型模式分为以下 7 种：
代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

以上 7 种结构型模式，除了适配器模式分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式


参考书籍
