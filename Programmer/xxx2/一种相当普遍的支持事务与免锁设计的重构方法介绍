一种相当普遍的支持事务与免锁设计的重构方法介绍
日期：2011-08-08 19:26浏览：431评论：4
一、场景与实现简介

        在许多产品中，存在大量动态配置表或数据库应用等，而对数据的并行读非常频繁，但是修改少。此类设计面临如下挑战：

      1 如何确保数据的事务性，比如表在批量更新过程中，失败了如何回滚。要么成功，要么什么都没做。

      2 更新过程耗时可能很长，如何避免阻塞业务的并发读访问，增强业务健壮性。

         以我们产品举例，最初实现是记录每步更新操作（实现可能参考了数据库的日志与事务处理），失败时再回滚每步操作，同时对读写过程加锁互斥访问。产品最初表比较少，而且主要在国内用，表结构和使用场景简单，还能应对。但伴随各个局点定制化需求越来越多，表数量急剧增加，且表与表有越来越多的依赖关系，比如操作不是针对单张表，而涉及到多张表，部分表成功，部分表失败，记录操作路径的代码复杂得根本无法维护，并且无法满足事务性要求了。         

二、重构步骤一：临时对象

        为简化事务操作，此时引入了一个现在看来非常简单的方法：对操作相关的表数据，生成临时的克隆对象，所有的更新均针对临时对象，当更新失败时，删除临时对象；更新成功后，交换业务访问的数据对象指针，删除老对象。效果显然易见：

     １回滚就是删除临时对象，再简单不过了。

     ２增强了业务可靠性：更新是对临时对象更新，更新过程不影响业务处理。

　   弊端：构建临时对象，对于海量数据就行不通了，此时可能就需要类同数据库的日志等复杂回滚机制了，但是对于大多数场景，其实我们不需要如此复杂的设计。

三、重构步骤二：延迟删除与免锁设计

         如何让众多读线程完全并发以满足更高性能要求呢？我们有采用读写锁等机制，但最终选择了免锁设计，如何免锁呢？

        由于重构步骤１采用临时对象很简单地就支持了事务，而对表的每次查询１毫秒内即可完成，如果在对临时对象完成更新后，延迟１秒（大于每次最大查询时间）删除老对象，就无需要对读写加锁，那么读就可完全并发了。因为业务线程可能在访问老数据，如果立刻删除就不得不对读写加锁；而延迟删除确保业务线程在访问老对象时不会被删除，而业务线程下一次访问就是访问新的对象了，故无需要加锁。

四　实现简介

      1 定义CAutoDeleteObject类，只有构造函数和虚的析构函数，函数均是空的，每个支持此模式的数据对象从此类继承。

    2 还要为所有数据操作实现如下两个函数：

 //传入新老对象，由bCommit指示是否更新或者抛弃更新。如果更新，要交换当前指针为pTmp，对于当前对象指针，由于免锁，可设置为volatile等方式避免多核下，某些线程依然获取的是老对象的指针。

 void Commit(CAutoRecycleObject *pTmp, CAutoRecycleObject *pOld, BOOL bCommit);

//按照指定时间延迟删除对象

 void ThrowToGarbage(CAutoRecycleObject* pObject, int iDelayMillSeconds);

     3  如何通知某操作相关的表对象生成临时对象并统一回滚或更新呢？此处采用了Observer模式，也就是每个数据对象记录了其关联关系，而我们有些实现也把这关联关系从对象本身剥离到一个中间者对象中管理（Midiator模式）。此处不细讲。

五　总结

         临时对象+延迟删除，很容易地支持了事务模式与免锁设计。其实很多设计与实现，不应该那么复杂，很多复杂化是人为原因导致，搞得编码处处战战兢兢，跟高科技似的。比如当初记录操作路径，又如引入读写锁，某些平台不支持，就自己实现读写锁，要想出这些招并维护这样的代码，是否要需要大牛人物呢？很多时候呼唤专家或英雄，但很少反思是否我们把本来应该简单的事情搞复杂化了。

      个人觉得重构的目标就是还简单的本来面目，如果设计与实现能真实地反映实际模型，大多数时候就不是复杂的，即使复杂，那样的复杂也是无法避免的。
