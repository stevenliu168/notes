对软件构建及其职责的剖析-太期望软件能做好了，欢迎拍砖
日期：2016-02-19 11:13浏览：1257评论：23
    晓晔让我对http://3ms.huawei.com/hi/group/2035349/blog_2036245.html?mapId=3196327&for_statistic_from=all_group_blog 一文分享下个人观点，可一回就没打住，就单独写了这篇博文，作为一名一直在一线从事开发11年多的老兵，对目前整个氛围对软件的看法（组织一直在不断尝试改变，许多方面也变得越来越好），有太多想说的。谈谈个人观点，对文中的观点做三点补充。

1、设计模式不是糖衣炮弹，更不要为模式而模式。单就编码过程来说，语言、工具与库三者缺一不可，工具与库等构件起来的生态环境甚至比语言本身更重要，不要单纯地把编码理解为语言与设计模式的应用，这远远不够。而站在整个软件角度去看，也就是以工程师的角度来审视整个软件构建过程，欠缺得更多，而最最欠缺的就是工程能力，比如工具与库的应用、文档化、集成、开发者测试等等。

2 、把MDE定位为模块设计，画地为牢，这个是否还合适呢？在80年代开放初，农村合作社转变为家庭承包制，每家都有一亩三分地，解放了生产力，可是吃饱后是否还合适呢？其实这种方式的生产力，相对于大规模集约化来说，它又是非常低效率的。我们需要的是看护整个软件构建过程，而不是其中一个片段，需要统筹运维，模块设计远远不够，而目前这是最欠缺的，这会导致整个软件，看着好像一些静态检查的KPI指标好了，其实软件本身的底子是不堪的，依然是人海战术，大量的低效率投入，比如集成测试效率低、一个小产品的资料都比操作系统的资料复杂、DFX流于形式、开一个局或升级一个基线版本要多少兄弟彻夜未眠（如果微软的操作系统做成这样，全球的工程师都不够它聘请）。而这些才是真真的软件效率关键所在，它是无法用静态检查等工具检测出来的，需要真真能接地气的技术Leader甚至一个精英小组来看护，它不仅仅是编码或者模块设计，是整个软件构建过程所需的知识与技能。

3、流程，对于一个“简单”软件（单纯去剖析各个业务产品，问题域本质的复杂度说不上是一个中大规模的软件，而构建出来的软件的复杂度可能远远大于问题域本身的复杂度，这就是耗费），这些软件产品，为啥要那么强调流程呢？原因在哪儿呢？业界完成同样复杂度的软件，核心团队可能跟我司有一个数量级的人数差距，原因就在这里，一流的软件公司，他的软件产品是由精英团队负责开发，简单地来说，比如开发时，一个人能把一个功能端到端搞定，而我们目前是怎样做的呢？强调分解（面向过程思想），问题域还未分析清楚，一开始就开始分解，分析（分解到不同功能包负责人或子系统负责人）、开发（又要分到N个模块的N个开发人员）、测试、资料、集成等等，一个简单功能可能前前后后就拉上数十号人，一点也不奇怪，沟通成本就远远大于软件构建本身所需要的成本，结果就要来强调流程和过程了，大部队摸着石头过河，整个构建过程中跌宕起伏，曲折不断，质量欠佳（不要单纯看宣传胶片的竞争力与技术，务虚包装的太多或报喜不报忧）也一点不为奇。而对于一个精英人员能端到端构建，流程就是“微”流程，试错与回炉成本也会低许多。所以，人海构建出来的软件质量欠佳，且复杂度远远超过问题域本身的复杂度一点不奇怪，“简单”软件是精英构建的，人员规模是匹配软件复杂的，但是软件复杂度不等同于问题域本身的复杂度，软件复杂度可能完全是人为导致的，而软件构建的挑战就是怎么让软件复杂度去匹配问题域本身的复杂度。

 

我们越是强调职责划分，越是强调流程，就越是忽略了人员的技能，软件构建的核心是人，而不是流程，软件构建本身是一个完整过程，软件构建远不等同于编码和调试！ 我们欠缺的是具备整个软件构建过程中所需要的知识及技能的合格软件工程师：既有设计、编码和测试方面的深度，同时还要具备分析、架构、工具、方法、文档化和工程等方面的宽度，不能把整个软件构建过程应具备的综合性知识和技能，按照过程定义的流程和活动分割成若干专职的角色，忽视人员技能就等于扼杀软件长期的开发维护效率及质量！

我们越是强调设计模式、强调模块看护，跟强调流程一样，也越是割裂本应该是一个完整的过程及其知识技能的应用，越是把软件开发过程应具备的综合性知识和技能，按照过程定义的流程和活动分割成若干专职的角色，忽视人员技能就等于扼杀软件长期的开发维护效率及质量！

 

所以，让我们回归到人的本质上来吧，我们太需要合格的软件工程师，不要割裂地去看，软件构建不是砌墙，无法像工厂那样规模化，软件构建过程本身就是一个充满创造的混沌过程，有许多的灰度无法精细化，我们就越要强调人员技能，从而精简人员，可以看看业界优秀的软件，无一不是一两个人或者一个精英团队铸就的，人员规模要匹配问题域本身的复杂度，而实际结果呢？我们软件的复杂度远远大于问题域本身的复杂度，从而导致任何一个“简单”产品，需要数倍的人力来维系，且质量本身还欠佳，主要表现如下：1）软件设计的质量欠佳： 软件开发容易误解为只是编码和调试，将客户需求转换为实现的设计职责缺失或者质量欠佳；2）忽视架构的看护与演进：创造架构相比整个生命周期是短暂的，而重视第一次铸造，忽视看护与演进最终导致架构“香消玉殒”，后期维护和再开发成本高；3）可提高生产率的优秀工具、先进方法、高可复用性的组件平台方案等难以普遍推广落地：不少人可能数年如一日用同一语言同一工具，为语言而语言，而不是把语言当一门工具，而不是根据问题域集成最合适的语言与工具，技术氛围与视野相对封闭；4）开发者测试质量薄弱，无法根治质量问题，例如单元测试更多停留在代码调试，难以自动化，开发者的测试继承性差，推高了后端的集成系统测试成本；5）软件构建的DFX等非功能性的软实力缺失，比如配置复杂、模块众多、接口众多，导致资料异常臃肿，一个基线版本升级会导致无数人彻夜未眠，这些能力缺失导致我们大量的人力消耗（其实是浪费），重复前面所说，换着微软像这么玩软件，全球的工程师可能都不够它聘。

 

割裂和强调某片段职责会导致人海战术，人海战术适合于家庭承包责任制时的解决温饱，但与大规模工业化的生产率差距巨大，软件构建本身需要的是精英，尤其是对于我司如此多的业务和产品，规模化工厂化的代价巨大， “匠人”或许更合适，而这也才是德日制造业和美国软件信息化强国的根本所在。精英化会释放大量人力去构建更多有价值的软件，从而把蛋糕做大，真真把软件做强做大。而不是就这点盘子上把竞争对手折腾死或精兵简政，或者发现一个新商业机会一大拨人砸进去就能砸个金娃娃，无论哪种，日子都过得紧巴巴或战战兢兢或异常奋斗者，就看干爹干妈奶多不多，能不能承受或承受多大的折腾，好一点的本质上还是逃脱不了硬件设备的配村，能多折腾几下，差等生只能数日子，不能乱花钱。

 

      备注：标题使用软件构建一词，它或许更能精准地描述某软件产品的开发过程，它远不等同于软件开发，还需要软件分析，软件架构，软件设计，软件测试，软件文档化产品化等的重叠，甚至在某些场景下囊括上述的一个完整过程，其实本质上也是难以单纯分割的（C语言之父，C++之父，Java之父，Linux之父，自由软件之父， John Carmack等被顶礼膜拜，因为他们是最杰出的程序员或者工程师，这才是本质，编译器、内核、各种处理技术的发明者与实现者，是软件最最核心的代码缔造者，基本也是软件使用文档的最权威作者，头衔太多，但本质就是程序员或工程师，远不只是某个片段的贡献者，并把这个片段的功放做大），我们可能太过一刀切地割裂地看不同问题域的软件构建过程了，本文越写越收不住，也主要针对于此。
发布
