设计模式培训
Security Level:


何为软件之美
好的代码/软件
什么是不好的代码/软件？
什么会造成不好的设计？
	什么会造成不好的设计
	软件需求的不断变化？
	设计和开发人员的技能较差？
	主观与客观上，时间紧任务重，硬塞代码，而罔顾软件设计的原则？
……


	大家是否遇到过以下场景
	我要实现的这个特性中有一些被频繁使用的代码，并且在其它特性中也被用到了，我不想总是做重复的事，那样费力且容易出错，因此需要一种方法能把这些稳固的代码抽象出来。
	这两个模块耦合太紧密了，代码一团糟，你中有我，我中有你，真令人抓狂！有什么办法彻底解耦吗？
	有一位兄弟的代码经过测试功能无误，但他的实现思路很奇怪，可读性差。我有更好的方法，但是必须首先说服他接受我的意见，我该拿出怎样权威的理由证明给他看呢？
	常听到有人抱怨说软件实现太灵活了，每个人都有不同的思路。那么如何才能让一个团队的代码看起来犹如同一个人写的那样，具有良好的可读性和可维护性呢？
         ……

代码往往是这样形成的
正确应对需求变化，让软件变美
设计模式的诞生与发展
	模式的诞生
	模式起源于建筑业而非软件业
	模式(Pattern)之父——美国加利佛尼亚大学环境结构中心研究所所长Christopher Alexander博士（克里斯托弗·亚历山大）
	《A Pattern Language: Towns, Buildings, Construction》——253个建筑和城市规划模式
	模式
•	Context（模式可适用的前提条件）
•	Theme或Problem（在特定条件下要解决的目标问题）
•	Solution（对目标问题求解过程中各种物理关系的记述）
	模式的定义 
	Alexander给出了关于模式的经典定义：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的解决方案，无需再重复相同的工作。 
	A pattern is a solution to a problem in a context 
     模式是在特定环境中解决问题的一种方案 

设计模式的诞生与发展

什么是设计模式？
	设计模式的定义 
设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。

	设计模式的基本要素
设计模式一般有如下几个基本要素：模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式，其中的关键元素包括以下四个方面：
•	模式名称 (Pattern name) 
•	问题 (Problem) 
•	解决方案 (Solution) 
•	效果 (Consequences) 
设计模式的定义与分类
	根据其目的（模式是用来做什么的）可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种：
•	创建型模式主要用于创建对象。
•	 结构型模式主要用于处理类或对象的组合。
•	 行为型模式主要用于描述对类或对象怎样交互和怎样分配职责。
	根据范围，即模式主要是用于处理类之间关系还是处理对象之间的关系，可分为类模式和对象模式两种：
•	类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时刻就被确定下来，是属于静态的。 
•	对象模式处理对象间的关系，这些关系在运行时刻变化，更具动态性。

设计模式分类
创建型模式概览

1.简单工厂：通过一个工厂类来创建一些列相关性的对象，对使用对象者隐藏具体对象，以及对象创建过程。

2.抽象工厂：
提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类，每个concreteFactory用于创建一个系列下的所有产品。当新增产品族的时候，通过新增ConcreteFactory来实现。


3.工厂方法：
定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 使一个类的实例化延迟到其子类。当需要新增产品时，通过新增ConcreteCreator来解决。


4.建造者：
将一个复杂对象各部件的组装过程与每个部件的具体创建分离，使得通用的构建过程可以创建不同的产品，当新增一个产品时，仅需要新增一个concreteBuilder类。


5.原型：
通过拷贝原型来创建新的对象，适用于通过拷贝来创建对象比实例化对象更加方便的时候。当新增创建对象类型时，可以通过新增ConcretePrototype来实现。


6.单例：
保证一个类仅有一个实例，并提供一个访问它的全局访问点。在多线程下需要有并发访问控制保证实例唯一性。



结构型模式概览
7.适配器：
将一个类的接口转换为客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。适用于功能部分已经存在但是对外接口却是新定义的情况。该模式主要解决接口适配的问题，有类适配与对象适配二类。该模式中变化的是Adapter类，不变的Adaptee类。


8.桥接：
将抽象部分与它的实现部分分离，使它们都可以独立地变化。适用于接口确定但是实现可以灵活实现和变化的情况。通过抽象部分对不同的实现部分聚合实现多维桥接。


9.组合：
将对象组合成树形结构以表示“部分-整体”的层次结构，组合使得用户对单个对象和组合对象的使用具有一致性。适用于可以忽略单个对象与整体对象的不同，客户端可以统一地使用组合结构中的所有对象。对于扩展的component和leaf客户端可以不感知。


10.装饰器：
通过组合而不是继承实现，可以动态地给一个对象添加一些额外的职责，可以形成链式装饰，该模式可在不影响被装饰对象的情况下，以动态、透明的方式给单个对象添加功能。适用于不改变已有对象功能的前提下增加新功能的情况。该模式中不变的是ConcreteComponent，变化的是Decorator。

11.外观：
为系统中的一组接口提供一个一致的界面，Facade模式在一个子系统中定义了一个高层接口，该接口使得子系统使用更加容易使用。适用于为一个复杂子系统提供简单接口、减少客户端与子系统的耦合等场景。


12.享元：
运用共享技术有效地支持大量细粒度的对象。适用于应用使用大量的对象造成很大的存储开销且对象的大多数状态都可变为外部状态的场景。

13.代理：
为其他对象提供一种代理以控制这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用和保护目标对象的作用。适用于需要访问或者使用某个对象的功能，但是无法直接访问和使用或者需要控制直接访问和使用的情况。可通过增加Proxy提供不同的代理机制。
行为型模式概览
14.模版方法：
定义一个操作中的算法的骨架，而将一些步骤的实现延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的特定步骤。该模式中不变的是方法操作步骤，可变的是每个步骤具体的实现。可通过新增ConcreteClass来新重定义步骤的具体实现。

15.职责链：
使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。适用于具有统一处理接口的多个对象中的一个处理某一个请求的情况。当需要新增处理请求的对象的时候，通过新增ConcreteHandle来实现。

16.命令：
将请求对象封装为一个对象，从而使可用不同的请求对客户进行参数化。命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。

17.迭代器：
提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示，该模式为不同聚合对象的访问提供统一接口，支持多种遍历方式且对外不暴露被遍历对象的内部实现。该模式中Iterator接口是不变的，新增访问方式仅需要扩展ConcreteIterator，新增ConcreteAggregate则同时需要新增ConcreteIterator。适用于多个对象数据的遍历情况。

18.中介者：
用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式的互相引用，从而使耦合松散，而且可以独立地改变它们之间的交互。适用于多个对象之间相互访问的情况，新增ConcreteColleague只需要改变ConcreteMediator，与其他ConcreteColleague无关。

19.备忘录：
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后可以将该对象恢复到原先保存到状态。适用于必须保存对象某一时刻的状态，并在以后进行恢复的场景。原发器只能生成和访问备忘录而不能操作备忘录，备忘录由负责人进行管理。

20.观察者：
定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。该模式将观察者与被观察者解耦，增加观察者时被观察者不感知，适用于一个对象改变需要同时改变其他对象的场景。

21.状态：
当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。状态模式主要解决的是当控制一个对象状态的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简单化。

22.策略：
定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。使得算法可独立于它的客户而变化，当新增算法的时候，通过新增ConcreteStrategy来实现。

23.访问者：
表示作用于某对象结构中的各元素的操作。它可以在不改变各元素的类的前提下定义作用于这些元素的新操作。适用于类的层次稳定而对类的访问方法变化的场景，新增访问方式仅需要增加ConcreteVisitor即可。

24.解释器：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

如何学习设计模式？

统一建模语言UML
	UML定义
	统一建模语言(Unified Modeling Language，UML)是一种为面向对象系统的产品进行说明、可视化和编制文档的一种标准语言，是非专利的第三代建模和规约语言。UML是面向对象设计的建模工具，独立于任何具体程序设计语言。


	UML的定义包括UML语义和UML表示法两部分
	UML语义：UML对语义的描述使开发者能在语义上取得一致的认识，消除了因人而异的表达方法所造成的影响；
	UML表示法：UML表示法定义UML符号的表示法，为开发者或者开发工具使用这些图形符号和文本语法为系统建模提供了标准

	设计模式和UML
	UML是统一的建模语言，在设计模式的描述中大量使用；
	UML仅仅是建模工具，目的是提供统一的、标准的、可视化的描述，UML不体现设计思想


详情参见
https://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html

统一建模语言UML
UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、顺序图（时序图）、合作图、组件图、部署图等 9 种图。
可以使用公司的cloudmodeling进行绘制，https://cloudmodeling.tools.huawei.com/
设计模式中中经常用到的类图，类之间的关系和对象交互的顺序图。


类图
	 类
类（Class）是指具有相同属性、方法和关系的对象的抽象，它封装了数据和行为，是面向对象程序设计（OOP）的基础，具有封装性、继承性和多态性等三大特性。在 UML 中，类使用包含类名、属性和操作且带有分隔线的矩形来表示。
(1) 类名（Name）是一个字符串，例如，Student。
(2) 属性（Attribute）是指类的特性，即类的成员变量。UML 按以下格式表示：
[可见性]属性名:类型[=默认值]
例如：-name:String
注意：“可见性”表示该属性对类外的元素是否可见，包括公有（Public）、私有（Private）、受保护（Protected）和朋友（Friendly）（C++中有友元函数和友元类，可以访问访问类对象的私有成员）4 种，在类图中分别用符号+、-、#、~表示。
(3) 操作（Operations）是类的任意一个实例对象都可以使用的行为，是类的成员方法。UML 按以下格式表示：
[可见性]名称(参数列表)[:返回类型]
例如：+display():void

	接口
接口（Interface）是一种特殊的类，它具有类的结构但不可被实例化，只可以被子类实现。它包含抽象操作，但不包含属性。它描述了类或组件对外可见的动作。在 UML 中，接口使用一个带有名称的小圆圈来进行表示。

类图与类之间的关系
	 类图
类图（ClassDiagram）是用来显示系统中的类、接口、协作以及它们之间的静态结构和关系的一种静态模型。它主要用于描述软件系统的结构化设计，帮助人们简化对软件系统的理解，它是系统分析与设计阶段的重要产物，也是系统编码与测试的重要模型依据。
类图中的类可以通过某种编程 语言直接实现。类图在软件系统开发的整个生命周期都是有效的，它是面向对象系统的建模中最常见的图。
下图所示，“计算长方形和圆形的周长与面积”的类图，图形接口有计算面积和周长的抽象方法，长方形和圆形实现这两个方法供访问类调用。

	 类之间的关系
在软件系统中，类不是孤立存在的，类与类之间存在各种关系。根据类与类之间的耦合度从弱到强排列，UML 中的类图有以下几种关系：依赖关系、关联关系、聚合关系、组合关系、泛化关系和实现关系。其中泛化和实现的耦合度相等，它们是最强的。





泛化与实现
泛化关系(generalization)
类的继承结构表现在UML中为：泛化(generalize) ：
继承非抽象类
继承关系为 is-a的关系；两个对象之间如果可以用 is-a 来表示，就是继承关系：（..是..)
eg：自行车是车、猫是动物
泛化关系用一条带空心箭头的直接表示；如下图表示（A继承自B）

聚合与组合关系

聚合关系(aggregation)

聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；

聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；
与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如， 部门撤销了，人员不会消失，他们依然存在；

关联关系与依赖关系
关联关系(association)

关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系， 通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；
比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；
关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图，表示A知道B，但 B不知道A；

注：在最终代码中，关联对象通常是以成员变量的形式实现的；



复杂的UML类图
设计原则与设计模式的关系
设计原则是战略，设计模式是战术。

Don’t Repeat Yourself (DRY)
不要重复，DRY 是一个最简单的法则，也是最容易被理解的。当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法。

Keep It Simple, Stupid (KISS)
保持简单，KISS原则在设计上可能最被推崇的。例如“宜家”（IKEA）简约、效率的家居设计、生产思路； “谷歌”（Google)简约、直接的商业风格，而苹果公司的iPhone/iPad将这个原则实践到了极至。

Program to an interface, not an implementation
这是设计模式中最根本的哲学，注重和依赖接口，而不是实现。接口是抽象和稳定的，实现则是多种多样的。


You Ain’t Gonna Need It (YAGNI)
YAGNI原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。例如架构师设计系统时，会考虑很多扩展性的东西，使用了大量折衷，导致项目失败。


共同封装原则
共同封装原则表示应该将容易变的类放在同一个包里，将变化隔离出来。

设计原则与设计模式的关系
高内聚低耦合
在软件设计中，耦合度和内聚度是用来衡量模块独立程度的标准。划分模块的一个准则是高内聚低耦合。在类的层次上常常是减少类对其他类的调用，从功能模块式上看往往是减少模块之间的交互模式，从方法的层次上看是减少一个类之间方法之间的相互调用。
常用的降低耦合度的方法，降低耦合度的常用方法有：
1. 少使用类的继承，多用接口来隐藏实现。
2. 模块的功能尽量单一，因为单一功能的模块被其他模块依赖的机会就少。
3. 少使用全局变量
4. 类和方法尽量申明为private ，只将必要对外方法申明为public
5. 尽量不要使用硬编码，也不要用SQL 语句操作数据库
6. 避免直接操作或调用其它模块或类，如果必须存在耦合，原则上尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，避免使用内容耦合。
设计原则与设计模式的关系
组合大于继承
在我们编码的过程中，我们往往为了从一个类扩展功能，我们会选择继承。然而， Java 中，继承只能是单继承，这样一来，当一个类继承了另一个类，就无法再从其它的类进行继承扩展。
Joshua J. Bloch 曾担任过Google 的首席Java架构师，在他的书《Effective Java》中指明了上面这个问题，他认为使用组合比继承更灵活，并且具有更好的扩展性。另外，Java的类加载机制也是采用双亲委托机制，这个机制就是采用组合的方式来组织类加载器的父子关系。可见，组合相对于继承有更广泛的应用，在Java中应该慎用继承。
